
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<center><h1>
        Java千百问_07JVM架构（018）_如何监控jvm的运行情况            
        </h1></center>, <div class="article_content tracking-ad" data-dsm="post" data-mod="popu_307" id="article_content">
<div class="markdown_views"><p><a href="http://blog.csdn.net/ooppookid/article/category/6134850">点击进入_更多_Java千百问</a></p>
<h3 id="1如何监控jvm的运行情况">1、如何监控jvm的运行情况</h3>
<p>了解jvm内存模型看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51418312">java内存模型是什么样的</a> <br>
了解jvm内存管理看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51469926">jvm是如何管理内存的</a> <br>
了解jvm垃圾回收机制看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51523486">java垃圾回收机制是什么</a> <br>
了解jvm内存优化看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51582772">java内存如何优化</a></br></br></br></p>
<p>我们通常使用<font color="#ff0000">Jdk工具</font>来监控jvm的运行情况，当然目前有很多第三方产品是通过<font color="#ff0000">jdk提供的api</font>来组织数据进行监控的。具体来说有如下监控软件：</p>
<ul>
<li><p><font color="#33ccff">Jconsole</font> <br>
jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。</br></p></li>
<li><p><font color="#33ccff">JavaVisualVM</font> <br>
JDK自带，功能强大，与JProfiler类似。推荐使用，通过jdk/bin/jvisualvm即可启动。</br></p></li>
<li><p><font color="#33ccff">JProfiler</font> <br>
商业软件，需要付费。功能强大。</br></p></li>
</ul>
<h3 id="2监控软件都能监控什么">2、监控软件都能监控什么</h3>
<p>上面这些调优工具都提供了强大的功能，但是总的来说一般都类似，能够监控<font color="#ff0000">CPU、内存、线程</font>等信息。</p>
<p>例如<font color="#ff0000">JavaVisualVM</font>具有以下几类功能：<font color="#ff0000">CPU、堆、类、线程关键信息</font>，<font color="#ff0000">手动进行垃圾回收GC</font>，<font color="#ff0000">线程详细信息</font>，<font color="#ff0000">CPU、内存抽样信息</font>，<font color="#ff0000">生成堆Dump、线程Dump</font></p>
<p>了解Dump文件看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51530756">什么是Dump文件</a></p>
<p><strong><font color="#33ccff">CPU、堆、类、线程关键信息</font></strong> <br>
图形化CPMU、堆、类、线程关键信息供我们查看，并且可以通过”执行垃圾回收”可以手动进行垃圾回收GC。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074615663" title=""/></br></br></p>
<p><strong><font color="#33ccff">线程详细信息</font></strong> <br>
应用中每个线程的详细信息，包括运行时、休眠、等待、驻留、监视等状态的线程。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074628382" title=""/></br></br></p>
<p><strong><font color="#33ccff">CPU、内存抽样信息</font></strong> <br>
通过收集一段时间的CPU、内存运行数据，展示内存和线程的详细信息。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074637273" title=""/></br></br></p>
<p><strong><font color="#33ccff">生成堆Dump、线程Dump</font></strong> <br>
通过生成某个应用的<font color="#ff0000">堆、线程Dump</font>来分析具体的Dump文件。 <br>
通过堆Dump可以监控：<font color="#ff0000">堆详细概要信息</font>，<font color="#ff0000">堆内类对象分析</font>，<font color="#ff0000">堆内对象实例详细信息</font>，<font color="#ff0000">OQL堆信息自定义查询</font> <br>
通过线程Dump可以监控：<font color="#ff0000">线程状态变化</font>，<font color="#ff0000">线程堆栈信息</font></br></br></br></p>
<p>如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074651164" title=""/></br></p>
<p><strong><font color="#33ccff">堆详细概要信息</font></strong> <br>
展示堆Dump的概要信息，包括堆基本信息、环境、系统属性、堆转储上的线程。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074702914" title=""/></br></br></p>
<p><strong><font color="#33ccff">堆内类对象分析</font></strong> <br>
展示堆内使用到的所有类，以及它们的实例数和占用大小。默认按照实例数倒序。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074715122" title=""/></br></br></p>
<p><strong><font color="#33ccff">堆内对象实例详细信息</font></strong> <br>
通过类可以进入指定类的实例详细信息，包括每一个实例的详细信息。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074727482" title=""/></br></br></p>
<p><strong><font color="#33ccff">OQL堆信息自定义查询</font></strong> <br>
通过OQL语言查询我们想得到的结果。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074744575" title=""/></br></br></p>
<p><strong><font color="#33ccff">线程Dump信息</font></strong> <br>
通过打印线程堆栈，展示线程状态变化，以及运行信息。如图： <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20160605074808357" title=""/></br></br></p>
<p>我们能够根据我们监控的到信息，能够让我们<font color="#ff0000">发现代码的问题</font>，<font color="#ff0000">优化的办法</font>。</p></div>
<script type="text/javascript">
            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        </script>
</div>]
</body>
</html>
